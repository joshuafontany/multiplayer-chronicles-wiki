{"tiddlers":{"$:/plugins/commons/multiserver/commands/multi-listen.js":{"title":"$:/plugins/commons/multiserver/commands/multi-listen.js","text":"/*\\\ntitle: $:/plugins/commons/multiserver/commands/multi-listen.js\ntype: application/javascript\nmodule-type: command\n\nServe tiddlers using a two-way websocket server over http\n\n\\*/\n\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\"use strict\";\n\nexports.info = {\n\tname: \"multi-listen\",\n\tsynchronous: true,\n\tnamedParameterMode: true,\n\tmandatoryParameters: []\n};\n\nconst MultiServer = require('$:/plugins/commons/multiserver/multiserver.js').MultiServer;\n\nconst Command = function (params, commander, callback) {\n\tlet self = this;\n\tthis.params = params;\n\tthis.commander = commander;\n\tthis.callback = callback;\n};\n\nCommand.prototype.execute = function () {\n\tif(!$tw.boot.wikiTiddlersPath) {\n\t\t$tw.utils.warning(\"Warning: Wiki folder '\" + $tw.boot.wikiPath + \"' does not exist or is missing a tiddlywiki.info file\");\n\t\treturn;\n\t}\n\tlet self = this;\n\t// Set up http(s) server\n\tthis.server = new MultiServer({\n\t\twiki: this.commander.wiki,\n\t\trequiredPlugins: [\n\t\t\t\"$:/plugins/commons/multiserver\",\n\t\t\t\"$:/plugins/tiddlywiki/filesystem\",\n\t\t\t\"$:/plugins/tiddlywiki/tiddlyweb\"\n\t\t].join(','),\n\t\tvariables: self.params\n\t});\n\t// Listen\n\tlet nodeServer = this.server.listen();\n\t$tw.utils.log(`TiddlyWiki v${$tw.version} MultiServer`);\n\t$tw.hooks.invokeHook(\"th-server-command-post-start\", this.server, nodeServer, \"tiddlywiki\");\n\treturn null;\n};\n\nexports.Command = Command;","type":"application/javascript","module-type":"command"},"$:/config/commons/multiserver/MIMEMap":{"title":"$:/config/commons/multiserver/MIMEMap","type":"application/json","note":"The file extensions and their associated mime-types that the server is allowed to serve.","text":"{\r\n  \".aac\": \"audio/aac\",\r\n  \".avi\": \"video/x-msvideo\",\r\n  \".bmp\": \"image/bmp\",\r\n  \".css\": \"text/css\",\r\n  \".csv\": \"text/csv\",\r\n  \".doc\": \"application/msword\",\r\n  \".epub\": \"application/epub+zip\",\r\n  \".gif\": \"image/gif\",\r\n  \".html\": \"text/html\",\r\n  \".htm\": \"text/html\",\r\n  \".ico\": \"image/x-icon\",\r\n  \".jpg\": \"image/jpeg\",\r\n  \".jpeg\": \"image/jpeg\",\r\n  \".mp3\": \"audio/mpeg\",\r\n  \".mp4\": \"video/mp4\",\r\n  \".mpeg\": \"video/mpeg\",\r\n  \".odp\": \"application/vnd.oasis.opendocument.presentation\",\r\n  \".ods\": \"application/vnd.oasis.opendocument.spreadsheet\",\r\n  \".odt\": \"application/vnd.oasis.opendocument.text\",\r\n  \".oga\": \"audio/ogg\",\r\n  \".ogv\": \"video/ogg\",\r\n  \".ogx\": \"application/ogg\",\r\n  \".otf\": \"font/otf\",\r\n  \".pdf\": \"application/pdf\",\r\n  \".ppt\": \"application/vnd.ms-powerpoint\",\r\n  \".png\": \"image/png\",\r\n  \".svg\": \"image/svg+xml\",\r\n  \".tif\": \"image/tiff\",\r\n  \".tiff\": \"image/tiff\",\r\n  \".ttf\": \"font/ttf\",\r\n  \".txt\": \"text/plain\",\r\n  \".wav\": \"audio/wav\",\r\n  \".weba\": \"audio/weba\",\r\n  \".webm\": \"video/webm\",\r\n  \".webp\": \"image/webp\",\r\n  \".woff\": \"font/woff\",\r\n  \".woff2\": \"font/woff2\",\r\n  \".xml\": \"text/xml\"\r\n}\r\n"},"$:/config/commons/multiserver":{"title":"$:/config/commons/multiserver","text":"{\n  \"servername\": \"Yjs.wiki\",\n  \"port\": 8080,\n  \"host\": \"127.0.0.1\",\n  \"path-prefix\": \"\",\n  \"admin\": \"(authenticated)\",\n  \"readers\": \"(anon)\",\n  \"writers\": \"(authenticated)\",\n  \"username\": \"\",\n  \"password\": \"\",\n  \"credentials\": \"\",\n  \"tls-key\": \"\",\n  \"tls-cert\": \"\",\n  \"tls-passphrase\": \"\",\n  \"debug-level\": \"none\",\n  \"root-render-type\": \"text/plain\",\n  \"root-serve-type\": \"text/html\",\n  \"root-tiddler\": \"$:/core/save/all\",\n  \"system-tiddler-render-template\": \"$:/core/templates/wikified-tiddler\",\n  \"system-tiddler-render-type\": \"text/plain\",\n  \"tiddler-render-template\": \"$:/core/templates/server/static.tiddler.html\",\n  \"tiddler-render-type\": \"text/html\"\n}\n"},"$:/plugins/commons/multiserver/license.md":{"title":"$:/plugins/commons/multiserver/license.md","text":"The MIT License (MIT)\r\n\r\nCopyright (c) 2021\r\n    - Joshua Fontany <joshua.fontany@gmail.com>\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","type":"text/markdown"},"$:/plugins/commons/multiserver/multiserver.js":{"title":"$:/plugins/commons/multiserver/multiserver.js","text":"/*\\\r\ntitle: $:/plugins/commons/multiserver/multiserver.js\r\ntype: application/javascript\r\nmodule-type: library\r\n\r\n\r\n\\*/\r\n\r\n/*jslint node: true, browser: true */\r\n/*global $tw: false */\r\n\"use strict\";\r\n\r\nif($tw.node) {\r\n\tconst fs = require(\"fs\"),\r\n\t\tpath = require(\"path\"),\r\n\t\tServer = require(\"$:/core/modules/server/server.js\").Server,\r\n\t\tCONFIG_HOST_TIDDLER = \"$:/config/tiddlyweb/host\";\r\n\r\n\t/*\r\n\t  A simple node server for Yjs, extended from the core server module\r\n\t  options: \r\n\t*/\r\n\tfunction MultiServer(options) {\r\n\t\toptions.variables = $tw.utils.extend($tw.boot.settings,options.variables);\r\n\t\tServer.call(this, options);\r\n\t\t// Initialise admin authorization principles\r\n\t\tvar authorizedUserName = (this.get(\"username\") && this.get(\"password\")) ? this.get(\"username\") : null;\r\n\t\tthis.authorizationPrincipals[\"admin\"] = (this.get(\"admin\") || authorizedUserName).split(',').map($tw.utils.trim);\r\n\t\t// Save the CONFIG_HOST_TIDDLER to disk\r\n\t\t$tw.wiki.addTiddler($tw.wiki.getTiddler(CONFIG_HOST_TIDDLER));\r\n\t\t// Add all the routes, this also loads and adds authorization priciples for each wiki\r\n\t\tthis.addWikiRoutes();\r\n\t}\r\n\r\n\tMultiServer.prototype = Object.create(Server.prototype);\r\n\tMultiServer.prototype.constructor = MultiServer;\r\n\r\n\tMultiServer.prototype.defaultVariables = Server.prototype.defaultVariables;\r\n\r\n\t/*\r\n\t  Load each wiki. Log each wiki's authorizationPrincipals as `${state.boot.pathPrefix}/readers` & `${state.boot.pathPrefix}/writers`.\r\n\t*/\r\n\tMultiServer.prototype.addWikiRoutes = function () {\r\n\t\tlet server = this,\r\n\t\t\treaders = this.authorizationPrincipals[\"readers\"],\r\n\t\t\twriters = this.authorizationPrincipals[\"writers\"];\r\n\t\t// Setup the other wiki routes\r\n\t\t$tw.utils.each($tw.boot.wikiInfo.serveWikis, function (group,groupPrefix) {\r\n\t\t\t$tw.utils.each(group, function (serveInfo) {\r\n\t\t\t\tlet state = $tw.utils.loadStateWiki(groupPrefix,serveInfo);\r\n\t\t\t\tif(state) {\r\n\t\t\t\t\t// Save the CONFIG_HOST_TIDDLER to disk\r\n\t\t\t\t\tstate.wiki.addTiddler(state.wiki.getTiddler(CONFIG_HOST_TIDDLER));\r\n\t\t\t\t\t// Add the authorized principal overrides\r\n\t\t\t\t\tif(!!serveInfo.readers) {\r\n\t\t\t\t\t\treaders = serveInfo.readers.split(',').map($tw.utils.trim);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif(!!serveInfo.writers) {\r\n\t\t\t\t\t\twriters = serveInfo.writers.split(',').map($tw.utils.trim);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tserver.authorizationPrincipals[`${state.boot.pathPrefix}/readers`] = readers;\r\n\t\t\t\t\tserver.authorizationPrincipals[`${state.boot.pathPrefix}/writers`] = writers;\r\n\t\t\t\t\t$tw.utils.log(\"Added route \" + state.boot.pathPrefix);\r\n\t\t\t\t};\r\n\t\t\t});\r\n\t\t});\r\n\t};\r\n\r\n\tMultiServer.prototype.isAdmin = function (username) {\r\n\t\tif(!!username) {\r\n\t\t\treturn this.isAuthorized(\"admin\", username);\r\n\t\t} else {\r\n\t\t\treturn null;\r\n\t\t}\r\n\t}\r\n\r\n\tMultiServer.prototype.getUserAccess = function (username, pathPrefix) {\r\n\t\tpathPrefix = pathPrefix || '';\r\n\t\tif(!!username) {\r\n\t\t\tlet type, accessPath = pathPrefix ? pathPrefix + '/' : '';\r\n\t\t\ttype = (this.isAuthorized(accessPath + \"readers\", username)) ? \"readers\" : null;\r\n\t\t\ttype = (this.isAuthorized(accessPath + \"writers\", username)) ? \"writers\" : type;\r\n\t\t\ttype = (this.isAuthorized(\"admin\", username)) ? \"admin\" : type;\r\n\t\t\treturn type;\r\n\t\t} else {\r\n\t\t\treturn null;\r\n\t\t}\r\n\t}\r\n\r\n\tMultiServer.prototype.requestHandler = function (request, response, options) {\r\n\t\toptions = options || {};\r\n\t\t// Test for OPTIONS\r\n\t\tif(request.method === 'OPTIONS') {\r\n\t\t\tresponse.writeHead(204, {\r\n\t\t\t\t\"Access-Control-Allow-Origin\": \"*\",\r\n\t\t\t\t\"Access-Control-Allow-Headers\": \"*\",\r\n\t\t\t\t\"Access-Control-Allow-Methods\": \"OPTIONS, HEAD, POST, GET, PUT, DELETE\",\r\n\t\t\t\t'Access-Control-Max-Age': 2592000 //30 Days\r\n\t\t\t})\r\n\t\t\tresponse.end()\r\n\t\t\treturn\r\n\t\t}\r\n\t\t// Check for a wikiState route\r\n\t\toptions = this.findStateOptions(request, options);\r\n\t\t// Call the parent method\r\n\t\tObject.getPrototypeOf(MultiServer.prototype).requestHandler.call(this, request, response, options);\r\n\t};\r\n\r\n\tMultiServer.prototype.findStateOptions = function (request, options) {\r\n\t\toptions = options || {};\r\n\t\tlet potentialMatch = $tw;\r\n\t\t$tw.states.forEach(function (state, key) {\r\n\t\t\tvar match = Object.prototype.toString.call(state.boot.regexp) == '[object RegExp]' && state.boot.regexp.exec(request.url);\r\n\t\t\tif(match) {\r\n\t\t\t\tpotentialMatch = state;\r\n\t\t\t}\r\n\t\t});\r\n\t\toptions.boot = potentialMatch.boot;\r\n\t\toptions.wiki = potentialMatch.wiki;\r\n\t\toptions.pathPrefix = potentialMatch.boot.pathPrefix;\r\n\t\tif(potentialMatch.boot.pathPrefix) {\r\n\t\t\toptions.authorizationType = potentialMatch.boot.pathPrefix + \"/\" + (this.methodMappings[request.method] || \"readers\");\r\n\t\t}\r\n\t\treturn options;\r\n\t};\r\n\r\n\texports.MultiServer = MultiServer;\r\n\r\n}","type":"application/javascript","module-type":"library"},"$:/plugins/commons/yjs/readme":{"title":"$:/plugins/commons/yjs/readme","caption":"readme","text":"! Yjs\n\nYjs is a high-performance CRDT for building collaborative applications that sync automatically.\n\nIt exposes its internal CRDT model as shared data types that can be manipulated concurrently. Shared types are similar to common data types like Map and Array. They can be manipulated, fire events when changes happen, and automatically merge without merge conflicts.\n\nThis plugins imports the core Yjs libraries into the TW5 module system.\n\nhttps://github.com/yjs/yjs\n\nThis repository contains a collection of shared types that can be observed for changes and manipulated concurrently. Network functionality and two-way-bindings are implemented in separate modules.\n\n! Yjs Docs\n\nhttps://docs.yjs.dev/\r\n"},"$:/plugins/commons/multiserver/startup.js":{"title":"$:/plugins/commons/multiserver/startup.js","text":"/*\\\ntitle: $:/plugins/commons/multiserver/startup.js\ntype: application/javascript\nmodule-type: startup\n\nInitialise the multiserver settings and root config tiddler\n\n\\*/\n\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\"use strict\";\n\n// Export name and synchronous status\nexports.name = \"multiwiki-startup\";\nexports.platforms = [\"node\"];\nexports.before = [\"startup\"];\nexports.after = [\"info\"];\nexports.synchronous = true;\n\nif($tw.node) {\n\nconst fs = require('fs'),\n    path = require('path'),\n    CONFIG_HOST_TIDDLER = \"$:/config/tiddlyweb/host\",\n    DEFAULT_HOST_TIDDLER = \"$protocol$//$host$/\",\n    SETTINGS_FILE = \"multiserver.info\";\n\nexports.startup = function() {\n    // Initialise the multiserver settings\n    let settings, target = path.join($tw.boot.wikiPath, \"settings\", SETTINGS_FILE);\n    try {\n        settings = JSON.parse(fs.readFileSync(target));\n    } catch (err) {\n        $tw.utils.log(`Multiserver - Error reading file ${target}, using default settings.`);\n        $tw.utils.log(\"Error: \"+err.toString())\n        settings = {};\n    }\n    $tw.boot.settings = $tw.utils.extend($tw.wiki.getTiddlerData(\"$:/config/commons/multiserver\", {}), settings);\n    // Init the root state\n    $tw.boot.origin = $tw.boot.settings.origin || DEFAULT_HOST_TIDDLER.replace(/\\/$/, '');\n    $tw.boot.pathPrefix = $tw.boot.settings[\"path-prefix\"] || \"\";\n    $tw.boot.regexp = null;\n    $tw.boot.serveInfo = {\n        name: $tw.boot.pathPrefix,\n        path: $tw.boot.pathPrefix || \"./\"\n    };\n    // Setup the config tiddler. For backwards compatibility we use $:/config/tiddlyweb/host\n    let tiddler = $tw.wiki.getTiddler(CONFIG_HOST_TIDDLER),\n    newFields = {\n        title: CONFIG_HOST_TIDDLER,\n        text: `${$tw.boot.origin}${$tw.boot.pathPrefix}/`,\n        origin: $tw.boot.origin\n    };\n    $tw.wiki.addTiddler(new $tw.Tiddler(tiddler,newFields));\n};\n\n}","type":"application/javascript","module-type":"startup"},"$:/plugins/commons/multiserver/utils/states.js":{"title":"$:/plugins/commons/multiserver/utils/states.js","text":"/*\\\ntitle: $:/plugins/commons/multiserver/utils/states.js\ntype: application/javascript\nmodule-type: utils-node\n\nVarious static utility functions.\n\n\\*/\n\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\"use strict\";\n\nconst fs = require('fs'),\n\tpath = require('path'),\n\twidget = require(\"$:/core/modules/widgets/widget.js\"),\n\tCONFIG_HOST_TIDDLER = \"$:/config/tiddlyweb/host\";\n\n$tw.states = $tw.states || new Map();\n\n// State methods\nfunction State(wikiPrefix,serveInfo) {\n\tlet self = this;\n\tthis.boot = {\n\t\tfiles: [],\n\t\torigin: $tw.boot.origin,\n\t\tpathPrefix: wikiPrefix,\n\t\tregexp: new RegExp(`^(${wikiPrefix})/?(.+)?$`),\n\t\tserveInfo: serveInfo,\n\t\twikiInfo: null,\n\t\twikiPath: path.resolve($tw.boot.wikiPath, serveInfo.path),\n\t\twikiTiddlersPath: null\n\t};\n\tthis.wiki = new $tw.Wiki();\n\n\t// Create a root widget for attaching event handlers.\n\t// By using it as the parentWidget for another widget tree, one can reuse the event handlers\n\tthis.rootWidget = new widget.widget({\n\t\ttype: \"widget\",\n\t\tchildren: []\n\t}, {\n\t\twiki: this.wiki,\n\t\tdocument: $tw.fakeDocument\n\t});\n\n\t// Load the boot tiddlers (from $tw.loadTiddlersNode)\n\t$tw.utils.each($tw.loadTiddlersFromPath($tw.boot.bootPath), function (tiddlerFile) {\n\t\tself.wiki.addTiddlers(tiddlerFile.tiddlers);\n\t});\n\t// Load the core tiddlers\n\tthis.wiki.addTiddler($tw.loadPluginFolder($tw.boot.corePath));\n\t// Load any extra plugins\n\t$tw.utils.each($tw.boot.extraPlugins, function (name) {\n\t\tif(name.charAt(0) === \"+\") { // Relative path to plugin\n\t\t\tvar pluginFields = $tw.loadPluginFolder(name.substring(1));\n\t\t\tif(pluginFields) {\n\t\t\t\tself.wiki.addTiddler(pluginFields);\n\t\t\t}\n\t\t} else {\n\t\t\tvar parts = name.split(\"/\"),\n\t\t\t\ttype = parts[0];\n\t\t\tif(parts.length === 3 && [\"plugins\", \"themes\", \"languages\"].indexOf(type) !== -1) {\n\t\t\t\tself.loadPlugins([parts[1] + \"/\" + parts[2]], $tw.config[type + \"Path\"], $tw.config[type + \"EnvVar\"]);\n\t\t\t}\n\t\t}\n\t});\n\t// Load the tiddlers from the wiki directory\n\tthis.boot.wikiInfo = this.loadWikiTiddlersNode(this.boot.wikiPath);\n\t// Unpack plugin tiddlers\n\tthis.wiki.readPluginInfo();\n\tthis.wiki.registerPluginTiddlers(\"plugin\", $tw.safeMode ? [\"$:/core\"] : undefined);\n\tthis.wiki.unpackPluginTiddlers();\n\t// Process \"safe mode\"\n\tif($tw.safeMode) {\n\t\tthis.wiki.processSafeMode();\n\t}\n\t\n\t// Setup the config tiddler. For backwards compatibility we use $:/config/tiddlyweb/host\n\tlet tiddler = this.wiki.getTiddler(CONFIG_HOST_TIDDLER),\n\tnewFields = {\n\t\ttitle: CONFIG_HOST_TIDDLER,\n\t\ttext: `${$tw.boot.origin}${this.boot.pathPrefix}/`,\n\t\torigin: $tw.boot.origin\n\t};\n\tthis.wiki.addTiddler(new $tw.Tiddler(tiddler,newFields));\n\n\t/* // Register typed modules from the tiddlers we've just loaded\n\tthis.wiki.defineTiddlerModules();\n\t// And any modules within plugins, but don't overwrite the $tw modules!\n\tthis.wiki.eachShadow(function(tiddler,title) {\n\t\t\t// Don't define the module if it is overidden by an ordinary tiddler or it is already defined\n\t\t\tif(!$tw.utils.hop($tw.modules.titles,title) && !this.wiki.tiddlerExists(title) && tiddler.hasField(\"module-type\")) {\n\t\t\t\t\t// Define the module\n\t\t\t\t\t$tw.modules.define(tiddler.fields.title,tiddler.fields[\"module-type\"],tiddler.fields.text);\n\t\t\t}\n\t}); */\n\t// Execute any startup actions\n\tthis.rootWidget.invokeActionsByTag(\"$:/tags/StartupAction\");\n\tthis.rootWidget.invokeActionsByTag(\"$:/tags/StartupAction/Node\");\n\t// Clear outstanding tiddler store change events to avoid an unnecessary refresh cycle at startup\n\tthis.wiki.clearTiddlerEventQueue();\n\t// Attach the syncadaptor & syncer\n\t// Find a working syncadaptor\n\tthis.syncadaptor = undefined;\n\t$tw.modules.forEachModuleOfType(\"syncadaptor\", function (title, module) {\n\t\tif(!self.syncadaptor && module.adaptorClass) {\n\t\t\tself.syncadaptor = new module.adaptorClass({\n\t\t\t\tboot: self.boot,\n\t\t\t\twiki: self.wiki\n\t\t\t});\n\t\t}\n\t});\n\t// Set up the syncer object if we've got a syncadaptor\n\tif(this.syncadaptor) {\n\t\tthis.syncer = new $tw.Syncer({\n\t\t\twiki: this.wiki,\n\t\t\tsyncadaptor: this.syncadaptor\n\t\t});\n\t}\n}\n\nState.prototype = Object.create(Object.prototype);\nState.prototype.constructor = State;\n\n/*\n\tplugins: Array of names of plugins (eg, \"tiddlywiki/filesystemadaptor\")\n\tlibraryPath: Path of library folder for these plugins (relative to core path)\n\tenvVar: Environment variable name for these plugins\n*/\nState.prototype.loadPlugins = function (plugins, libraryPath, envVar) {\n\tif(plugins) {\n\t\tvar pluginPaths = $tw.getLibraryItemSearchPaths(libraryPath, envVar);\n\t\tfor (var t = 0; t < plugins.length; t++) {\n\t\t\tthis.loadPlugin(plugins[t], pluginPaths);\n\t\t}\n\t}\n};\n\n/*\n\tname: Name of the plugin to load\n\tpaths: array of file paths to search for it\n*/\nState.prototype.loadPlugin = function (name, paths) {\n\tvar pluginPath = $tw.findLibraryItem(name, paths);\n\tif(pluginPath) {\n\t\tvar pluginFields = $tw.loadPluginFolder(pluginPath);\n\t\tif(pluginFields) {\n\t\t\tthis.wiki.addTiddler(pluginFields);\n\t\t\treturn;\n\t\t}\n\t}\n\t$tw.utils.log(`Warning cannot find plugin://'root${this.boot.pathPrefix}/#${name}'`);\n};\n\n/* \n\tpath: path of wiki directory\n\toptions:\n\t\t\tparentPaths: array of parent paths that we mustn't recurse into\n\t\t\treadOnly: true if the tiddler file paths should not be retained\n*/\nState.prototype.loadWikiTiddlersNode = function (wikiPath, options) {\n\toptions = options || {};\n\tlet self = this,\n\t\tparentPaths = options.parentPaths || [],\n\t\twikiInfoPath = path.resolve(wikiPath, $tw.config.wikiInfo),\n\t\twikiInfo,\n\t\tpluginFields;\n\t// Bail if we don't have a wiki info file\n\tif(fs.existsSync(wikiInfoPath)) {\n\t\twikiInfo = JSON.parse(fs.readFileSync(wikiInfoPath, \"utf8\"));\n\t} else {\n\t\t$tw.utils.log(`loadWikiTiddlersNode error, unable to find '${wikiInfoPath}'`);\n\t\treturn null;\n\t}\n\t// Save the path to the tiddlers folder for the filesystemadaptor\n\tlet config = wikiInfo.config || {};\n\tif(this.boot.wikiPath == wikiPath) {\n\t\tthis.boot.wikiTiddlersPath = path.resolve(this.boot.wikiPath, config[\"default-tiddler-location\"] || $tw.config.wikiTiddlersSubDir);\n\t}\n\t// Load any included wikis\n\tif(wikiInfo.includeWikis) {\n\t\tparentPaths = parentPaths.slice(0);\n\t\tparentPaths.push(wikiPath);\n\t\t$tw.utils.each(wikiInfo.includeWikis, function (info) {\n\t\t\tif(typeof info === \"string\") {\n\t\t\t\tinfo = {\n\t\t\t\t\tpath: info\n\t\t\t\t};\n\t\t\t}\n\t\t\tlet resolvedIncludedWikiPath = path.resolve(wikiPath, info.path);\n\t\t\tif(parentPaths.indexOf(resolvedIncludedWikiPath) === -1) {\n\t\t\t\tlet subWikiInfo = self.loadWikiTiddlersNode(resolvedIncludedWikiPath, {\n\t\t\t\t\tparentPaths: parentPaths,\n\t\t\t\t\treadOnly: info[\"read-only\"]\n\t\t\t\t});\n\t\t\t\t// Merge the build targets\n\t\t\t\twikiInfo.build = $tw.utils.extend([], subWikiInfo.build, wikiInfo.build);\n\t\t\t} else {\n\t\t\t\t$tw.utils.warning(\"Cannot recursively include wiki \" + resolvedIncludedWikiPath);\n\t\t\t}\n\t\t});\n\t}\n\t// Load any plugins, themes and languages listed in the wiki info file\n\tthis.loadPlugins(wikiInfo.plugins, $tw.config.pluginsPath, $tw.config.pluginsEnvVar);\n\tthis.loadPlugins(wikiInfo.themes, $tw.config.themesPath, $tw.config.themesEnvVar);\n\tthis.loadPlugins(wikiInfo.languages, $tw.config.languagesPath, $tw.config.languagesEnvVar);\n\t// Load the wiki files, registering them as writable\n\tlet resolvedWikiPath = path.resolve(wikiPath, $tw.config.wikiTiddlersSubDir);\n\t$tw.utils.each($tw.loadTiddlersFromPath(resolvedWikiPath), function (tiddlerFile) {\n\t\tif(!options.readOnly && tiddlerFile.filepath) {\n\t\t\t$tw.utils.each(tiddlerFile.tiddlers, function (tiddler) {\n\t\t\t\tself.boot.files[tiddler.title] = {\n\t\t\t\t\tfilepath: tiddlerFile.filepath,\n\t\t\t\t\ttype: tiddlerFile.type,\n\t\t\t\t\thasMetaFile: tiddlerFile.hasMetaFile,\n\t\t\t\t\tisEditableFile: config[\"retain-original-tiddler-path\"] || tiddlerFile.isEditableFile || tiddlerFile.filepath.indexOf(self.boot.wikiTiddlersPath) !== 0\n\t\t\t\t};\n\t\t\t});\n\t\t}\n\t\tself.wiki.addTiddlers(tiddlerFile.tiddlers);\n\t});\n\tif(this.boot.wikiPath == wikiPath) {\n\t\t// Save the original tiddler file locations if requested\n\t\tlet output = {},\n\t\t\trelativePath, fileInfo;\n\t\tfor (let title in this.boot.files) {\n\t\t\tfileInfo = this.boot.files[title];\n\t\t\tif(fileInfo.isEditableFile) {\n\t\t\t\trelativePath = path.relative(this.boot.wikiTiddlersPath, fileInfo.filepath);\n\t\t\t\tfileInfo.originalpath = relativePath;\n\t\t\t\toutput[title] =\n\t\t\t\t\tpath.sep === \"/\" ?\n\t\t\t\t\trelativePath :\n\t\t\t\t\trelativePath.split(path.sep).join(\"/\");\n\t\t\t}\n\t\t}\n\t\tif(Object.keys(output).length > 0) {\n\t\t\tthis.wiki.addTiddler({\n\t\t\t\ttitle: \"$:/config/OriginalTiddlerPaths\",\n\t\t\t\ttype: \"application/json\",\n\t\t\t\ttext: JSON.stringify(output)\n\t\t\t});\n\t\t}\n\t}\n\t// Load any plugins within the wiki folder\n\tlet wikiPluginsPath = path.resolve(wikiPath, $tw.config.wikiPluginsSubDir);\n\tif(fs.existsSync(wikiPluginsPath)) {\n\t\tlet pluginFolders = fs.readdirSync(wikiPluginsPath);\n\t\tfor (let t = 0; t < pluginFolders.length; t++) {\n\t\t\tpluginFields = $tw.loadPluginFolder(path.resolve(wikiPluginsPath, \"./\" + pluginFolders[t]));\n\t\t\tif(pluginFields) {\n\t\t\t\tthis.wiki.addTiddler(pluginFields);\n\t\t\t}\n\t\t}\n\t}\n\t// Load any themes within the wiki folder\n\tlet wikiThemesPath = path.resolve(wikiPath, $tw.config.wikiThemesSubDir);\n\tif(fs.existsSync(wikiThemesPath)) {\n\t\tlet themeFolders = fs.readdirSync(wikiThemesPath);\n\t\tfor (let t = 0; t < themeFolders.length; t++) {\n\t\t\tpluginFields = $tw.loadPluginFolder(path.resolve(wikiThemesPath, \"./\" + themeFolders[t]));\n\t\t\tif(pluginFields) {\n\t\t\t\tthis.wiki.addTiddler(pluginFields);\n\t\t\t}\n\t\t}\n\t}\n\t// Load any languages within the wiki folder\n\tlet wikiLanguagesPath = path.resolve(wikiPath, $tw.config.wikiLanguagesSubDir);\n\tif(fs.existsSync(wikiLanguagesPath)) {\n\t\tlet languageFolders = fs.readdirSync(wikiLanguagesPath);\n\t\tfor (let t = 0; t < languageFolders.length; t++) {\n\t\t\tpluginFields = $tw.loadPluginFolder(path.resolve(wikiLanguagesPath, \"./\" + languageFolders[t]));\n\t\t\tif(pluginFields) {\n\t\t\t\tthis.wiki.addTiddler(pluginFields);\n\t\t\t}\n\t\t}\n\t}\n\treturn wikiInfo;\n};\n\n// Multi Wiki methods\n/*\n\tThis function loads a wiki into a named state object.\n*/\nexports.loadStateWiki = function (groupPrefix,serveInfo) {\n\tif(typeof serveInfo === \"string\") {\n\t\tserveInfo = {\n\t\t\tname: path.basename(serveInfo),\n\t\t\tpath: serveInfo\n\t\t};\n\t}\n\tlet state = null,\n\t\tfinalPath = path.resolve($tw.boot.wikiPath, serveInfo.path),\n\t\twikiPrefix = ($tw.boot.pathPrefix ? `/${$tw.boot.pathPrefix}/${groupPrefix}/` : `/${groupPrefix}/`) + encodeURIComponent(serveInfo.name),\n\t\tloaded = $tw.utils.hasStateWiki(wikiPrefix);\n\tif(!$tw.utils.isDirectory(finalPath)) {\n\t\t$tw.utils.warning(\"loadWikiState error, '\" + wikiPrefix + \"': \" + JSON.stringify(serveInfo, null, 2));\n\t\tserveInfo = null;\n\t}\n\t// Check for duplicates, we can't serve the same wiki at two different paths\n\tif(finalPath == path.resolve($tw.boot.wikiPath, \".\")) {\n\t\t$tw.utils.warning(\"loadWikiState duplicate, '\" + wikiPrefix + \"' has already been loaded as the server root wiki.\");\n\t\tloaded = true;\n\t} else {\n\t\t$tw.states.forEach(function (state,name) {\n\t\t\tif(finalPath == path.resolve($tw.boot.wikiPath, state.boot.serveInfo.path)) {\n\t\t\t\t$tw.utils.warning(\"loadWikiState duplicate, '\" + wikiPrefix + \"' has already been loaded as '\" + state.boot.pathPrefix + \"'.\");\n\t\t\t\tloaded = true;\n\t\t\t}\n\t\t});\n\t}\n\t// Make sure it isn't loaded already\n\tif(serveInfo && !loaded) {\n\t\t// Init the tiddlywiki state instance\n\t\tstate = new State(wikiPrefix,serveInfo);\n\t\t$tw.utils.setStateWiki(wikiPrefix,state);\n\t\t$tw.hooks.invokeHook('wiki-loaded',serveInfo.name);\n\t}\n\treturn state;\n};\n\nexports.hasStateWiki = function (pathPrefix) {\n\treturn $tw.boot.pathPrefix == pathPrefix || $tw.states.has(pathPrefix)\n}\n\nexports.getStateWiki = function (pathPrefix) {\n\tlet state = null;\n\tif($tw.boot.pathPrefix == pathPrefix) {\n\t\tstate = $tw;\n\t} else if($tw.states.has(pathPrefix)) {\n\t\tstate = $tw.states.get(pathPrefix);\n\t}\n\treturn state;\n}\n\nexports.setStateWiki = function (pathPrefix,state) {\n\tif($tw.boot.pathPrefix !== pathPrefix) {\n\t\t$tw.states.set(pathPrefix, state)\n\t}\n}","type":"application/javascript","module-type":"utils-node"}}}